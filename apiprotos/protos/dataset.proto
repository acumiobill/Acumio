syntax = "proto3";

import "attributes.proto";
import "description.proto";
import "names.proto";
import "google/protobuf/descriptor.proto";

package acumio.model;
option java_package = "com.acumio.model";

message UnknownDataset {
  // message is intentionally empty.
}

message UnknownBinary {
  // Note that it is common for the name to not be known in an
  // UnknownBinary, in which case, the attributes of name are
  // empty.
  QualifiedName name = 1;
}

message SemiStructuredDataset {
  // Note that it is common for there to be no "logical" name
  // for the SemiStructuredDataset, in which case the attributes
  // of this "name" are empty. Another possibility is that the name
  // simply mirrors the physical name, e.g., the file location.
  QualifiedName name = 1;

  // The keys are how we want to reference a given structure. Using the fully
  // qualifed name might be one way, but it assumes that we don't re-use
  // the same basic StructuredType with different semantics. A better way
  // is to assume we have a number of named methods for extracting content.
  map<string, StructuredType> structure = 2;
}

message SortSpec {
  message SortPair {
    string column = 1;
    // Defaults to false so that sorting is defaulted to ascending.
    bool sort_descending = 2;
  }

  repeated SortPair attribute = 1;
}

message PartitionSpec {
  // TODO: Differentiate Hash-Partitions and Range-Partitions and
  //       Range-Hash partitions.
  repeated string partition_column = 1;
  int32 num_partitions = 2;
}


message FreeFormDataset {
  // Note that it is common for there to be no "logical" name
  // for a FreeFormDataset, in which case the attributes
  // of name are empty. Another possibility is that the name
  // simply mirrors the physical name, e.g., the file location.
  QualifiedName name = 1;
}

message PropertyPair {
  string key = 1;
  string value = 2;
}

message RelationalDbFormat {
  // Format should match logical description exactly for the base schema.
  // We add properties here to match the requirements of the different
  // vendors.
  repeated PropertyPair property = 1;
}

// Have will contain a RelationalDbFormat. Hive has some interesting
// idiosynchrosies to warrant special treatment.
message HiveDbFormat {
  message SkewSpec {
    message SimpleValueEntry {
      // The number of values here should match the number of columns.
      repeated SimpleValue value = 1;
    }
    repeated string column = 1;
    repeated SimpleValueEntry entry = 2;
  }

  RelationalDbFormat base_format = 1;
  SkewSpec skew = 2;
}

message TextFileFormat {
  enum EncodingStyle {
    UNKNOWN = 0;
    DOS = 1;
    UNIX = 2;
  }

  EncodingStyle style = 1;
}

// Not sure what to do with a JSON format. Knowing that a format is a JSON
// format is not generally sufficient to provide the complete intended
// mapping to a dataset. We will probably add more to this as we build
// use-cases. For the moment, the structure has no inherent attributes.
// Some thoughts for options:
//   * Strip out outer-level Object structures until the kth "[" is found.
//     (The kth "[" indicates that we are finally getting to the repetition
//      of records).
//   * Filter records within the kth "[" to pick out only those values
//     correpsonding to keys with a given object path.
//   * Perhaps use some sort of JSON query language.
//     Candidates:
//        * JSONPath
//        * JaQL
//        * JSON Query
message JsonFormat {
  
}

message CsvFormat {
  string attribute_separator = 1; // Canonical is ",", but "|" is also common.
  string record_separator = 2; // Canonical is "\n"
}

message ProtoFormat {
  // TODO: Rename this attribute. It's a bit wordy with "proto_descriptor",
  // but "descriptor" fails since the generated code already includes a
  // method called "descriptor".
  google.protobuf.DescriptorProto proto_descriptor = 1;
}

message AvroFormat {
  // Avro defines their schemas by way of a JSON record, and can therefore
  // be easily represented as a string. Conversion from an Avro format to
  // a logical schema type should be pretty feasible.
  string schema = 1;
}

message ThriftFormat {
  // Thrift compiles its formats from .thrift files. It is unclear how we
  // might recognize a given binary file as generated by objects complying
  // to a .thrift format, but in the event that these can be recognized,
  // we record them here. It should be noted that AFAIK, Thrift is rarely used
  // as a record-storage format. Instead, it is more likely to be used as
  // an RPC exchange format.
  string schema = 1;
}

message OrcFormat {
  repeated PropertyPair property = 1;
}

message Discovery {
  // Have we at least started the exploration of logical type?
  // Not logical schema, but logical type: relational vs structured
  // vs unstructured, etc.
  bool logical_type_explored = 1;
  // Are we now confident that we know the logical type? Again, not
  // necessarily the schema, but the type?
  bool logical_type_discovered = 2;
  // Have we at least started the exploration of the physical type?
  // When we first encounter a file, we might only know its filename
  // without knowing type. Before we actually examine the contents
  // of a file however, we cannot really say that we have explored
  // its type. Note that based on filename extension, we might have
  // a good guess about the physical type: but we still reserve the
  // notion of explored until such time as we open the file. If we
  // infer the physical type from file name, we will set the physical
  // type as such, but just not mark it as actually explored.
  bool physical_type_explored = 3;
  // Are we confident that we know the physical type?
  bool physical_type_discovered = 4;

  // TODO: Add other discovery items. Need to walk through our
  //       discovery process to really fill this out. Not a critical
  //       item at the moment.
}

// Design Discussion: A serious consideration for describing datasets -
// logical or physical - was to just use a proto3 ProtocolDescriptor. After
// all, ProtocolDescriptors are the native proto3 mechanism to describe types.
// There are at least 3 problems with using ProtocolDescriptors:
//     1) Common relational types - such as the FixedPointNumberType have to
//        be explicitly defined as new types with ProtocolDescriptors, and
//        then have to be located in a Protocol library.
//     2) There are some attribute types that simply cannot be expressed
//        directly in Proto3, but are expressable with Avro, for example.
//        However, Proto 3 can be used to express Avro indirectly, as we
//        do with this mechanism.
//     3) To make this work, we need to have direct access to the protocol
//        libraries used by the clients. However, this might not be feasible.
message Dataset {
  // Based on proto3 syntax, this introduces an enum (for C++):
  // enum LogicalTypeCase {
  //   kUnknown = 1;
  //   kRelational = 2;
  //   kStructured = 3;
  //   kSemiStructured = 4;
  //   kFreeForm = 5;
  //   kUnknownBinary = 6;
  //   LOGICAL_TYPE_NOT_SET = 0;
  // }
  // Other languages will have similar enums introduced.
  oneof logical_type {
    // If unknown, we just do not know how to classify it, or its
    // classification has not yet ben determined.
    //
    // Use-case: We have found some files that might comprise
    // a dataset, but we have not yet determined their format.
    //
    // Similar to the situation where logical_type_case() returns
    // LOGICAL_TYPE_NOT_SET.
    UnknownDataset unknown = 1;

    // All messages in Dataset hae a flat structure with each
    // attribute being of a primitive attribute type.
    // Use-case: Accessing a relational database table,  or a
    // different representation of the table on disk. Note that
    // you can define a dataset as relational even if it is not
    // part of a relational database - the tag strictly refers
    // to the structure of the data, not the storage format.
    RelationalType relational = 2;

    // All messages in Dataset have the same structure that could
    // be described by a single StructuredType.
    // Use-case: Standard key-value pair database where each value
    // can be described by a single class. Alternatively, just a
    // format that allows for more flexibility than a strict
    // relational model.
    // Use-case: JSON message log with uniform message types.
    StructuredType structured = 3;

    // It is feasible to tease apart different messages within the
    // dataset, but each message will have fundamentally different
    // characteristics. In particular, there might be completely
    // different protos found, or JSON messages describing completely
    // different types, or even just free-form text.
    // Use-case: Log data. Often, JSON messages as well, but encoding
    // in JSON might imply either STRUCTURED or SEMI_STRUCTURED
    // formats.
    SemiStructuredDataset semi_structured = 4;

    // The content is strictly text (or nearly all text) and has no inherent
    // structure or mechanism to pull apart different messages. However, you
    // may separate parts of the messages by new-line character, or by spaces,
    // or sentences, or other mechanisms. This will also apply to most
    // web-pages, even if the format is not exactly "free-form" and not
    // entirely "text". So far as the strucutre is concerned, it has the
    // properties that:
    //    1) We can read it.
    //    2) There is no built-in structure other than our ability to
    //       read it.
    // Use-case: Shakespeare text document. Web page or other html
    // document. Note that .csv files would *not* come into this
    // category: most .csv files are actually RELATIONAL.
    // Note that while a free_form dataset may not have structure, the
    // contents can still be indexed by keyword.
    FreeFormDataset free_form = 5;
    // The content is in a binary format where we do not have sufficient
    // information to parse the content.
    // Use-case: Clearly, whenever we find something that we do not know
    // how to interpret. This is more informative than "UNKNOWN", because
    // it implies we did in fact *try* to interpret the message. We
    // were merely unsuccessful in doing so.
    UnknownBinary unknown_binary = 6;
  }

  // The physical_name maps to some path within a repository. For those
  // kinds of logical datasets that support having a QualifiedName, it
  // is common for the logical names and physical names to match, but
  // certainly not a requirement.
  QualifiedName physical_name = 7;

  // The name of the repository holding this physical dataset. This must
  // match the repository identified by the prefix to physical_name.
  QualifiedName repository_name = 8;

  // This list is likely to grow over time.
  // See "Data Discovery Notes" under the Acumio "Demo and Technical
  // Due Diligence Preparation" for more information.
  oneof format_type {
    RelationalDbFormat relational_db = 9;
    HiveDbFormat hive_db = 10;
    TextFileFormat text_file = 11;
    JsonFormat json = 12;
    CsvFormat csv = 13;
    ProtoFormat proto = 14;
    AvroFormat avro = 15;
    ThriftFormat thrift = 16;
    OrcFormat orc = 17; 
  }

  PartitionSpec partition = 18;
  SortSpec sort = 19;
  Discovery discovery = 20;
}

// We will use DatasetDescriptions in our APIs in a way that allows
// us to know which Datasets they apply to. The DatasetDescription
// itself does not have that knowledge.
// The reason not to put it directly on the Dataset itself is because
// we will want to manage the descriptions differently. It will be
// common to want just the Dataset without the Description, or sometimes,
// the other way around.
message DatasetDescription {
  Description description = 1;
  // Assuming a single RelationalType the keys are formed as the name
  // of the attributes.
  // If StructuredType, the keys are formed as the attribute path names.
  // So for example, if the attribute type is a simple type, it's just
  // the name of the attribute. However, for an attribute "foo" with
  // type MyStruct (which is a structured type) containing attributes
  // "bar" and "cat", the key "foo" refers to the overall structure,
  // and the key "foo.bar" refers to the "bar" attribute of "foo", and
  // the key "foo.cat" refers to the "cat" attribute of "foo". Similarly,
  // if there is a MapType attribute "foo" with the type for the value
  // of the MapType being MyStruct, then a similar naming convention
  // applies.
  // For a SemiStructured type, note that the SemiStructuredType has 
  // the structure attribute, which is a map from key-names to StructuredTypes.
  // So for example, if we have this map:
  //      "ErrorText"  : ErrorMessageLog
  //      "StackTrace" : StackTraceMesssage
  // With ErrorMessageLog formed as:
  //   { int32 error_code = 1; string error_message = 2}
  // and StackTrace formed as:
  //   { message Line { string source_file_name = 1; uint32 line_number = 2}
  //     repeated Line line = 1;
  //   }
  // We can give a description for "ErrorText" using the key "ErrorText",
  // and the key "ErrorText.error_code" to describe the error_code attribute
  // of ErrorMessageLog, and "StackTrace" to describe "StackTrace" and
  // "StackTrace.source_file_name" to describe the source_file_name attribute
  // of a StackTraceMessage.
  map<string, Description> attribute_description = 2;
}

message DatasetDescriptionHistory {
  DescriptionHistory dataset_history = 1;
  map<string, DescriptionHistory> attribute_history = 2;
}
